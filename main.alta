import Vector from "vector"
import uint8, uint16, Size, SizeMaximum from "types"
import Exception from "exceptions"
import parseNumber, numberToString from "util"
import String from "string"

export class InvalidComponentIndex extends Exception {}
export class InvalidAddress extends Exception {}

export class Address {
  private var _isV6 = false
  private var _components = new Vector<uint16>(6)

  public constructor() {
    for i: uint8 in 0..4 {
      this._components.push(0)
    }
  }
  public constructor(isIPV6: bool) {
    for i: uint8 in 0..(isIPV6 ? 8 : 4) {
      this._components.push(0)
    }
  }
  public @from constructor(address: String) {
    let found = false
    for i: Size in 0..address.length {
      if address[i] == ':' {
        found = true
        this._isV6 = true
        break
      } else if address[i] == '.' {
        found = true
        break
      }
    }
    if !found
      throw new InvalidAddress
    for i: uint8 in 0..(this._isV6 ? 8 : 4) {
      this._components.push(0)
    }

    if address.length == 2 && address[0] == ':' && address[1] == ':' {
      # do nothing
    } else if this._isV6 {
      let lastIdx: Size? = SizeMaximum # start with SizeMaximum so it'll wrap around to 0 when we do `from: *lastIdx + 1`
      let doubleIndex: uint8? = null
      let componentIdx: uint8 = 0
      while lastIdx {
        if componentIdx > 7
          throw new InvalidAddress

        let nextIdx = address.indexOf(':', after: *lastIdx)

        let substr = address.substring(from: *lastIdx + 1, to: nextIdx == SizeMaximum ? address.length : nextIdx)

        if substr.length == 0 {
          if doubleIndex
            throw new InvalidAddress
          doubleIndex = componentIdx
          if *lastIdx == SizeMaximum {
            nextIdx = address.indexOf(':', after: nextIdx)
          }
        } else {
          this._components[componentIdx++] = parseNumber<uint16>(substr, 16)
        }

        if nextIdx == SizeMaximum {
          lastIdx = null
        } else {
          lastIdx = nextIdx
        }

        if lastIdx && *lastIdx + 1 >= address.length {
          throw new InvalidAddress
        }
      }
      if !doubleIndex && componentIdx < 8
        throw new InvalidAddress
      if doubleIndex {
        let diff = this._components.length - componentIdx
        for i: uint8 in *doubleIndex..componentIdx {
          this._components[i + diff] = this._components[i]
        }
        for i: uint8 in *doubleIndex..*doubleIndex + diff {
          this._components[i] = 0
        }
      }
    } else {
      let first = address.indexOf('.')
      let second = address.indexOf('.', after: first)
      let third = address.indexOf('.', after: second)

      this._components[0] = parseNumber<uint16>(address.substring(from: 0, to: first))
      this._components[1] = parseNumber<uint16>(address.substring(from: first + 1, to: second))
      this._components[2] = parseNumber<uint16>(address.substring(from: second + 1, to: third))
      this._components[3] = parseNumber<uint16>(address.substring(from: third + 1, to: address.length))
    }
  }

  public @read function isIPV4(): bool {
    return !this._isV6
  }
  public @read function isIPV6(): bool {
    return this._isV6
  }

  # limit index to uint8 since we can only have up to 8 components
  # limit return value to uint16 since we components can have a maximum of 16 bits
  public this[uint8]: ref uint16 {
    if this._isV6 && $ > 7 {
      throw new InvalidComponentIndex
    } else if !this._isV6 && $ > 3 {
      throw new InvalidComponentIndex
    }
    return this._components[$]
  }

  public to String {
    if this._isV6 {
      let longestIdx: uint8 = 0
      let longestCount: uint8 = 0
      let currentCount: uint8 = 0
      let lastIdx: uint8 = 0

      for i: uint8 in 0..this._components.length {
        if this._components[i] == 0 {
          if longestCount == 0 || lastIdx + 1 != i {
            currentCount = 0
          }
          lastIdx = i
          ;++currentCount
          if currentCount > longestCount {
            longestCount = currentCount
            longestIdx = i + 1 - currentCount
          }
        }
      }

      if longestCount == this._components.length {
        return "::"
      }

      let result: String
      let isFirst = true

      if longestCount > 1 {
        for i: uint8 in 0..longestIdx {
          if isFirst {
            isFirst = false
          } else {
            result += ':'
          }
          result += numberToString<uint16>(this._components[i], 16)
        }

        result += ':'
        isFirst = false
      }

      for i: uint8 in (longestCount > 1 ? longestIdx + longestCount : 0)..this._components.length {
        if isFirst {
          isFirst = false
        } else {
          result += ':'
        }
        result += numberToString<uint16>(this._components[i], 16)
      }

      if longestIdx + longestCount == this._components.length {
        result += ':'
      }

      return result
    } else {
      return
        numberToString<uint16>(this._components[0], 10) + '.' +
        numberToString<uint16>(this._components[1], 10) + '.' +
        numberToString<uint16>(this._components[2], 10) + '.' +
        numberToString<uint16>(this._components[3], 10)
    }
  }
}
